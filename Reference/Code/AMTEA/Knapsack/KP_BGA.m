function [bestSol, fitness_hist] = KP_BGA(problem, dims, premSTOP) 
%[bestSol, fitness_hist] = BGA(problem,dims,th_best): simple binary GA with
%uniform crossover and bit-flip mutation. 
%INPUT:
% problem: problem generated by GenKnapsack
% dims: problem dimensionality
% premSTOP: used for early stop if no improvement is made for 20
% consecutive generations
%
%OUTPUT:
% bestSol: best solution
% fitness: history of best fitness for each generation

    % allmodels should be initialized as an empty cell array where 
    % source probability distributions are gradually stored
    load('./allmodels.mat');
    
    pop = 100;
    gen = 100;
    
    fitness_hist = zeros(gen, 1);
    population = round(rand(pop,dims));    
    fitness = funceval(population,problem,dims,pop);
    fitness_hist(1) = max(fitness);
    bestfitness = fitness_hist(1);
    disp(['Generation 1 best fitness = ',num2str(fitness_hist(1))]);
    
    counter = 0;
    for i = 2:gen
        parent1 = population(randperm(pop),:);
        parent2 = population(randperm(pop),:);
        tmp = rand(pop,dims);        
        offspring = zeros(pop,dims);
        index = tmp>=0.5;
        offspring(index) = parent1(index);
        index = tmp<0.5;
        offspring(index) = parent2(index);
        tmp = rand(pop,dims);
        index = tmp<(1/dims);
        offspring(index) = abs(1-offspring(index));
        cfitness = funceval(offspring,problem,dims,pop);
        interpop = [population;offspring];
        interfitness = [fitness;cfitness];
        [interfitness,index] = sort(interfitness,'descend');
        fitness = interfitness(1:pop);
        interpop = interpop(index,:);        
        population = interpop(1:pop,:);
        fitness_hist(i) = fitness(1);
        disp(['Generation ', num2str(i), ' best fitness = ',num2str(fitness_hist(i))]); 
   
        if fitness(1) > bestfitness
            bestfitness = fitness(1);
            counter = 0;
        else
            counter = counter+1;
        end
        if counter == 20 && premSTOP
            fitness_hist(i:end) = fitness_hist(i);
            break;
        end
    end
    
    bestSol = population(1, :);
    
    model = ProbabilityModel('umd');
    model = ProbabilityModel.buildmodel(model,population);
    allmodels{length(allmodels)+1} = model;
    save('allmodels','allmodels')
end

function fitness = funceval(population,problem,dims,pop)
    fitness = zeros(pop,1);
    Weights = problem.w';
    Profits = problem.p';
    Ratios = Profits./Weights;
    for i = 1:pop
        BV = population(i,:);
        TotalWeight = sum(BV*Weights);
        TotalProfit = sum(BV*Profits);
        
        if TotalWeight > problem.cap % Repair solution
            selections = sum(BV);
            List = zeros(selections,2);
            counter = 1;
            for j = 1 : dims
                if BV(j) == 1
                    List(counter,1) = Ratios(j);
                    List(counter,2) = j;
                    counter = counter + 1;
                end
                if counter > selections
                    break;
                end
            end
            List = sortrows(List,-1);
            counter = selections;
            while TotalWeight > problem.cap
                BV(List(counter,2)) = 0;
                TotalWeight = TotalWeight - Weights(List(counter,2));
                TotalProfit = TotalProfit - Profits(List(counter,2));
                counter = counter - 1;
            end
        end
        fitness(i) = TotalProfit;
    end
end